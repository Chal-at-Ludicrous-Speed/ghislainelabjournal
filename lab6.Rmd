---
title: "lab6"
author: "Ghislaine de Groot"
date: "2025-10-10"
output: html_document
---

### Packages

```{r. eval=FALSE}
library(foreign)
library(tidyverse)
library(scholar) 
library(openalexR)
library(rvest) 
library(jsonlite)
library(RSiena)

```


### Loading the journal dataset

```{r, eval=FALSE}

sjr2022 <- read_csv2('/Users/ghislaine/Downloads/Github/Social Networks/scimagojr 2022 Subject Category - Sociology and Political Science.csv')

sjr2024 <- read_csv2('/Users/ghislaine/Downloads/Github/Social Networks/scimagojr 2024 Subject Category - Sociology and Political Science.csv')

```

# Stealing niels vullings' code and linking the journals from SJR to the journals in the dataset

df_works doesn't work yet

```{r, echo=FALSE, eval=FALSE}

df_works_dataframe <- do.call(rbind.data.frame, sociologists$works)  # put works in dataframe
# head(df_works)

df_works_dataframe <- do.call(rbind.data.frame, sociologists$works)

```

### debugging

```{r, eval=FALSE}
fcolnet_n <- function(data = scholars, university = "RU", discipline = "sociology", waves = list(c(2015,
    2018), c(2019, 2023)), type = c("first")) {

    # step 1
    demographics <- do.call(rbind.data.frame, data$demographics)
    demographics <- demographics %>%
        mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), ""), Universiteit2.22 = replace(Universiteit2.22,
            is.na(Universiteit2.22), ""), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
            ""), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), ""), discipline.22 = replace(discipline.22,
            is.na(discipline.22), ""), discipline.24 = replace(discipline.24, is.na(discipline.24), ""))

    sample <- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in%
        university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in%
        university) & (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

    demographics_soc <- demographics[sample, ]
    scholars_sel <- lapply(scholars, "[", sample)

    # step 2
    ids <- demographics_soc$au_id
    nwaves <- length(waves)
    nets <- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works <- tibble(works_id = unlist(lapply(scholars_sel$work, function(l) l$id)), works_author = unlist(lapply(scholars_sel$work,
        function(l) l$author), recursive = FALSE), works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year),
        recursive = FALSE))

    df_works <- df_works[!duplicated(df_works), ]

    # step 4
    if (type == "first") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego <- df_works_w$works_author[i][[1]]$au_id[1]
                alters <- df_works_w$works_author[i][[1]]$au_id[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
                }
            }
        }
    }

    if (type == "last") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego <- rev(df_works_w$works_author[i][[1]]$au_id)[1]
                alters <- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
                }
            }
        }
    }

    if (type == "all") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos <- df_works_w$works_author[i][[1]]$au_id
                if (sum(ids %in% egos) > 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] <- 1
                }
            }
        }
    }
    output <- list()
    output$data <- scholars_sel
    output$nets <- nets
    return(output)
}
```




```{r, eval=FALSE}
scholars <- fload("./data/processed/scholars_20240924.rda")
```


```{r, eval=FALSE}
soc_data <- fcolnet_n(data = scholars, university = c("RU", "UU"), discipline = c("sociology"), waves = list(c(2015,
    2019), c(2020, 2024)), type = c("first"))


df_ego <- do.call(rbind.data.frame, soc_data$data$demographics)

df_works <- do.call(rbind.data.frame, soc_data$data$works)  # put works in dataframe
# head(df_works)

test1 <- df_works %>% select(id, so, issn_l, author) # test the works

soc_data$nets[2,,] # How to call a specific network

```

```{r, eval=FALSE}
df_works <- tibble(works_id, works_author, works_year)
```


```{r, eval=FALSE}
df_works_dataframe <- as.data.frame(unique(sociologists$works))

sociologists2 <- sociologists

require(reshape2)
install.packages("reshape2")


```


```{r, eval=FALSE}
test1 <- df_works %>% select(id, so, issn_l, author) # test the works
```

```{r, eval=FALSE}
# Split the ISSN codes if 2 are available

sjr2022$Issn_1 <- sapply(strsplit(sjr2022$Issn, ", "), `[`, 1)  # This code should work as a way to split the two issn codes
sjr2022$Issn_2 <- sapply(strsplit(sjr2022$Issn, ", "), `[`, 2)

sjr2024$Issn_1 <- sapply(strsplit(sjr2024$Issn, ", "), `[`, 1)  # This code should work as a way to split the two issn codes
sjr2024$Issn_2 <- sapply(strsplit(sjr2024$Issn, ", "), `[`, 2)

# dat$Issn_1[1] str_length(dat$Issn_1[1])

sjr2022$Issn_1 <- paste0(substr(sjr2022$Issn_1, 1, 4), "-", substr(sjr2022$Issn_1, 5, 8))  # Hyphenate the codes to match the target df 
sjr2022$Issn_2 <- ifelse(is.na(sjr2022$Issn_2) == TRUE, NA, paste0(substr(sjr2022$Issn_2, 1, 4), "-", substr(sjr2022$Issn_2,
    5, 8)))  # Hyphenate the codes, but make non-existing second codes NA

sjr2024$Issn_1 <- paste0(substr(sjr2024$Issn_1, 1, 4), "-", substr(sjr2024$Issn_1, 5, 8))  # Hyphenate the codes to match the target df 
sjr2024$Issn_2 <- ifelse(is.na(sjr2024$Issn_2) == TRUE, NA, paste0(substr(sjr2024$Issn_2, 1, 4), "-", substr(sjr2024$Issn_2,
    5, 8)))  # Hyphenate the codes, but make non-existing second codes NA


df_pres_22 <- sjr2022 %>%
    select(Rank, Title, Issn_1, Issn_2, SJR, `SJR Quartile`, `H index`, `%Female`)  # Make a set that will be joined with df_works

df_pres_24 <- sjr2024 %>%
    select(Rank, Title, Issn_1, Issn_2, SJR, `SJR Quartile`, `H index`, `%Female`)  # Make a set that will be joined with df_works

df_pres_22

# df_works %>% select(issn_l) df_pres %>% select(Issn_1, Issn_2)
df_works$check <- ifelse(df_works$issn_l %in% df_pres_22$Issn_1 | df_works$issn_l %in% df_pres_22$Issn_2, 1,
    0)

mis_journal <- df_works %>%
    filter(check == 0)

as.data.frame(unique(mis_journal$so))

```

### Create ID variable

```{r, eval=FALSE}

df_pres_22 <- df_pres_22 %>%
    mutate(issn_l = case_when(Issn_1 %in% df_works$issn_l == TRUE ~ Issn_1, Issn_2 %in% df_works$issn_l ==
        TRUE ~ Issn_2, .default = NA)) %>%
    filter(!is.na(issn_l))

df_pres_24 <- df_pres_24 %>%
    mutate(issn_l = case_when(Issn_1 %in% df_works$issn_l == TRUE ~ Issn_1, Issn_2 %in% df_works$issn_l ==
        TRUE ~ Issn_2, .default = NA)) %>%
    filter(!is.na(issn_l))

```

```{r, eval=FALSE}
#---- String Stripper ----
str_strip <- function(input = "THIs StrïnG is ÑorMälìZed") {

    string <- tolower(input)
    string <- iconv(string, from = "UTF-8", to = "ASCII//TRANSLIT")
    string <- sub(".* ", "", string)

    # string <- gsub('[[:punct:]]', ' ', string)

    return(string)
}

```



### Looping algorithm logic 

```{r, eval=FALSE}
list_works <- soc_data$data$works

df_ego$Q1.W1 <- 0
df_ego$Q1.W2 <- 0

for (i in 1:length(list_works)) {

    wave1s <- 2015
    wave1e <- 2019
    wave2s <- 2020
    wave2e <- 2024

    works <- list_works[[i]]

    works <- works %>%
        left_join(df_pres_24, by = "issn_l", multiple = "all")
    works$`SJR Quartile` <- ifelse(is.na(works$`SJR Quartile`), "No Rank", works$`SJR Quartile`)

    au <- works %>%
        unnest(author) %>%
        mutate(check_id = au_id %in% df_ego$au_id) %>%
        mutate(check_nam = str_strip(au_display_name) %in% str_strip(df_ego$Naam)) %>%
        filter(check_id == TRUE & check_nam == TRUE)

    works <- works %>%
        mutate(waves = case_when(publication_year >= wave1s & publication_year <= wave1e ~ "Wave 1",
            publication_year >= wave2s & publication_year <= wave2e ~ "Wave 2", .default = "NA")) %>%
        filter(waves != "NA")
    if (nrow(works) == 0) {

        next

    } else {

        for (x in 1:nrow(works)) {

            if (works$waves[x] == "Wave 1") {

                if (works$`SJR Quartile`[x] == "Q1") {

                  naam <- works$author[[x]]$au_display_name
                  df_ego[str_strip(df_ego$Naam) %in% str_strip(naam), ]$Q1.W1 <- df_ego[str_strip(df_ego$Naam) %in%
                    str_strip(naam), ]$Q1.W1 + 1

                }
            } else {

                if (works$`SJR Quartile`[x] == "Q1") {

                  naam <- works$author[[x]]$au_display_name
                  df_ego[str_strip(df_ego$Naam) %in% str_strip(naam), ]$Q1.W2 <- df_ego[str_strip(df_ego$Naam) %in%
                    str_strip(naam), ]$Q1.W2 + 1

                }
            }

        }

    }

}
```


### Career age

```{r, eval=FALSE}

df_career_age <- df_works %>%
  unnest(author) %>% # unnesting the tibble from the tibble
  filter(au_id %in% df_ego$au_id == TRUE) %>% # authors in df_works should match authors in df_ego
  group_by(au_id) %>%
  mutate(min_year_pub = min(publication_year, na.rm = TRUE), # initial calculation of minimum year
         count_pub = n()) %>%  # count number of publications
  mutate(first_year_pub = ifelse(count_pub == 1, min_year_pub, # if number of publications is 1, score is min_year_pub
                                 {
                                   filter_year = publication_year[publication_year != min_year_pub] # filter minimum year
                                   mean_pubyear = mean(filter_year, na.rm = TRUE) # calculate mean without min score
                                   valid_year = min(filter_year[filter_year >= (mean_pubyear - 25)], na.rm = TRUE) # minimum year -> range mean-25
                                   valid_year # if number of publications is not 1, than score minimum year with first year removed within range mean-25
                                 })) %>% 
  
  # this line corrects for the warning of returning infinites that for some reason were not filtered through the first ifelse command
  mutate(first_year_pub = ifelse(is.infinite(first_year_pub), min_year_pub, first_year_pub)) %>% #adjusting infinite scores to minimum year
  
  select(au_id, first_year_pub) %>% # selecting variables
  distinct(au_id, first_year_pub, .keep_all = TRUE) # making sure only distinct authors are in data frame  
  

df_ego <- df_ego %>% left_join(df_career_age, by = "au_id")


```

## Practicing with RSiena without prestige

### own fcolnet, different from niels

```{r, eval=FALSE}

fcolnet_25 <- function(data = scholars, university = "RU", discipline = "sociology", waves = list(c(2015,
    2018), c(2019, 2023)), type = c("first")) {

    # step 1
    demographics <- do.call(rbind.data.frame, data$demographics)
    demographics <- demographics %>%
        mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), ""), Universiteit2.22 = replace(Universiteit2.22,
            is.na(Universiteit2.22), ""), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
            ""), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), ""), discipline.22 = replace(discipline.22,
            is.na(discipline.22), ""), discipline.24 = replace(discipline.24, is.na(discipline.24), ""))

    sample <- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in%
        university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in%
        university) & (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

    demographics_soc <- demographics[sample, ]
    scholars_sel <- lapply(scholars, "[", sample)

    # step 2
    ids <- demographics_soc$au_id
    nwaves <- length(waves)
    nets <- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works <- tibble(works_id = unlist(lapply(scholars_sel$work, function(l) l$id)), works_author = unlist(lapply(scholars_sel$work,
        function(l) l$author), recursive = FALSE), works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year),
        recursive = FALSE))

    df_works <- df_works[!duplicated(df_works), ]

    # step 4
    if (type == "first") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego <- df_works_w$works_author[i][[1]]$au_id[1]
                alters <- df_works_w$works_author[i][[1]]$au_id[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
                }
            }
        }
    }

    if (type == "last") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego <- rev(df_works_w$works_author[i][[1]]$au_id)[1]
                alters <- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
                }
            }
        }
    }

    if (type == "all") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos <- df_works_w$works_author[i][[1]]$au_id
                if (sum(ids %in% egos) > 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] <- 1
                }
            }
        }
    }
    output <- list()
    output$data <- scholars_sel
    output$nets <- nets
    return(output)
}

```


```{r, eval=FALSE}

# soc_test_data <- sienaDataCreate(wave1, wave2)

soc_test_data <- sienaDependent(array(c(wave1, wave2), dim = c(386, 386)))
```

Trying to get a network for RSiena

```{r, eval=FALSE}
test_RU <- fcolnet_25(data = scholars, 
                    university = "RU",
                    discipline = "sociology", 
                    waves = list(c(2015, 2018), c(2019, 2023)), 
                    type = c("first"))

test_UvT <- fcolnet_25(data = scholars, 
                    university = "UvT",
                    discipline = "sociology", 
                    waves = list(c(2015, 2018), c(2019, 2023)), 
                    type = c("first"))

soc_test_data <- sienaDataCreate(test_RU, test_UvT)

soc_test_data <- sienaDependent(array(c(test_RU, test_UvT, dim = c(386, 386)))

```


# Two articles

We had to send in two articles before class. 


Hancean et al. (2014) is about collaboration networks across the 17 Romanian sociology departments. I found the theoretical section useful, as it listed previous empirical findings of collaboration network structures, I believe specifically in sociology. The first one, small-world networks were more often found in cross-disciplinary collaborations. "Collaboration networks that fit small-world models are expected to have many distinct clusters of researchers investigating specific subjects or implementing particular research projects, while the geodesics among these clusters are small (low number of links or degree of separation)" (Hancean et al., 2014, 2). The second one seems the most relevant to me, the **principle of preferential attachment**. "New links and nodes are not randomly connected to large networks, but based on observed power-law distributions", Matthew-effect: scientific fields grow and develop around highly prestigious scientific scholars. Thirdly, networks defined by structural cohesion, which are densely connected, with no vulnerabilities for fragmentation. Finally, the core-periphery model is defined as "networks consisting of one group (the core) to which all actors belong to a greater or lesser extent". 


Knoke and Yang (2011) explained how prestige works in social networks, that an ego receives much less ties that they receive.  


